
#include "stdafx.h"
#include <algorithm>
#include "OpenGLContext.h"
#include <gl/GL.h>

OpenGLContext::OpenGLContext(HWND hwnd) : mhwnd(hwnd)
    , mMouseVisible(true)
    , mContinuousUpdate(true)
    , mIgnoreNextMouseMoveEvent(false)
    , mFullscreen(false)
    , mHDC(NULL)
    , mHGLRC(NULL)
{
}

OpenGLContext::~OpenGLContext()
{
}

bool OpenGLContext::init(const OpenGLContextFormat& fmt)
{
    mHDC = ::GetDC(hwnd());
    if (!mHDC)
        return false;
    PIXELFORMATDESCRIPTOR pfd;
    memset(&pfd, 0, sizeof(pfd));
    pfd.nSize           = sizeof(pfd);
    pfd.nVersion        = 1;
    pfd.dwFlags         = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
    pfd.dwFlags         |= fmt.doubleBuffer() ? PFD_DOUBLEBUFFER : 0;
    pfd.dwFlags         |= fmt.stereo() ? PFD_STEREO : 0;
    pfd.iPixelType      = PFD_TYPE_RGBA;
    pfd.cColorBits      = 24;
    pfd.cRedBits        = (BYTE)fmt.rgbaBits().r();
    pfd.cGreenBits      = (BYTE)fmt.rgbaBits().g();
    pfd.cBlueBits       = (BYTE)fmt.rgbaBits().b();
    pfd.cAlphaBits      = (BYTE)fmt.rgbaBits().a();
    pfd.cAccumRedBits   = (BYTE)fmt.accumRGBABits().r();
    pfd.cAccumGreenBits = (BYTE)fmt.accumRGBABits().g();
    pfd.cAccumBlueBits  = (BYTE)fmt.accumRGBABits().b();
    pfd.cAccumAlphaBits = (BYTE)fmt.accumRGBABits().a();
    pfd.cDepthBits      = (BYTE)fmt.depthBufferBits();
    pfd.cStencilBits    = (BYTE)fmt.stencilBufferBits();
    pfd.iLayerType      = PFD_MAIN_PLANE;
    int pixel_format_index = ChoosePixelFormat(mHDC, &pfd);
    //// if this is not supported we use the current 'pixel_format_index' returned by ChoosePixelFormat above.
    //int samples = 0;
    //if(WGLEW_ARB_pixel_format && fmt.multisample())
    //{
    //  float fAttributes[] = { 0, 0 };
    //  int iAttributes[] =
    //  {
    //      // multi sampling
    //      WGL_SAMPLE_BUFFERS_ARB, GL_TRUE,
    //      WGL_SAMPLES_ARB,        -1, // this is set below
    //      // generic
    //      WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,
    //      WGL_SUPPORT_OPENGL_ARB, GL_TRUE,
    //      WGL_ACCELERATION_ARB,   WGL_FULL_ACCELERATION_ARB,
    //      // color buffer
    //      WGL_RED_BITS_ARB,         pfd.cRedBits,
    //      WGL_GREEN_BITS_ARB,       pfd.cGreenBits,
    //      WGL_BLUE_BITS_ARB,        pfd.cBlueBits,
    //      WGL_ALPHA_BITS_ARB,       pfd.cAlphaBits,
    //      // accumulation buffer
    //      WGL_ACCUM_RED_BITS_ARB,   pfd.cAccumRedBits,
    //      WGL_ACCUM_GREEN_BITS_ARB, pfd.cAccumGreenBits,
    //      WGL_ACCUM_BLUE_BITS_ARB,  pfd.cAccumBlueBits,
    //      WGL_ACCUM_ALPHA_BITS_ARB, pfd.cAccumAlphaBits,
    //      // depth buffer
    //      WGL_DEPTH_BITS_ARB,       pfd.cDepthBits,
    //      WGL_DOUBLE_BUFFER_ARB,    fmt.doubleBuffer() ? GL_TRUE : GL_FALSE,
    //      // stencil buffer
    //      WGL_STENCIL_BITS_ARB,     pfd.cStencilBits,
    //      // stereo
    //      WGL_STEREO_ARB,           fmt.stereo() ? GL_TRUE : GL_FALSE,
    //      0,0
    //  };
    //  for(samples = fmt.multisampleSamples(); samples > 1; samples/=2)
    //  {
    //      // sets WGL_SAMPLES_ARB value
    //      iAttributes[3] = samples;
    //      pixel_format_index = -1;
    //      UINT num_formats  = 0;
    //      if ( wglChoosePixelFormatARB(mHDC,iAttributes,fAttributes,1,&pixel_format_index,&num_formats) && num_formats >= 1 )
    //          break;
    //      else
    //          pixel_format_index = -1;
    //  }
    //}
    //if (pixel_format_index == -1)
    //  return false;
    if (SetPixelFormat(mHDC, pixel_format_index, NULL) == FALSE)
        return false;
    // OpenGL Rendering Context
    mHGLRC = wglCreateContext(mHDC);
    if (!mHGLRC)
        return false;
    wglMakeCurrent(mHDC, mHGLRC);
    initExtensions();
    glClearDepth(1.0f);
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);
    glDisable(GL_LIGHTING);
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
    if (fmt.multisample() && !WGLEW_ARB_multisample)
        return false;
    //dispatchInitEvent();
    if (WGLEW_EXT_swap_control)
        wglSwapIntervalEXT(fmt.vSync() ? 1 : 0);
    return true;
}

void OpenGLContext::release()
{
    if (mHGLRC)
    {
        wglDeleteContext(mHGLRC);
        mHGLRC = 0;
    }
    if (mHDC)
    {
        ReleaseDC(hwnd(), mHDC);
        mHDC = 0;
    }
    wglMakeCurrent(0, 0);
}

void OpenGLContext::shareOpenGLResources(HGLRC hGLRC)
{
    if (hwnd() && mHDC && mHGLRC)
        wglShareLists(hglrc(), hGLRC);
}

void OpenGLContext::initExtensions(bool log)
{
    makeCurrent();
    // init glew for each rendering context
    GLenum err = glewInit();
    if (GLEW_OK != err)
        fprintf(stderr, "Error calling glewInit(): %s\n", glewGetErrorString(err));
    // clears eventual OpenGL errors generated by GLEW
    glGetError();
}

bool OpenGLContext::isExtensionSupported(const char* ext_name)
{
    makeCurrent();
    int len = strlen(ext_name);
    const char* ext = (const char*)glGetString(GL_EXTENSIONS);
    const char* ext_end = ext + strlen(ext);
    for (const char* pos = strstr(ext, ext_name); pos && pos < ext_end; pos = strstr(pos, ext_name))
    {
        if (pos[len] == ' ' || pos[len] == 0)
            return true;
        else
            pos += len;
    }
    return false;
}

void OpenGLContext::quitApplication()
{
    wglDeleteContext(mHGLRC);
    mHGLRC = 0;
    ReleaseDC(hwnd(), mHDC);
    mHDC = 0;
    PostQuitMessage(0);
    //this->eraseAllEventListeners();
}

void OpenGLContext::update()
{
    if (hwnd())
        PostMessage(hwnd(), WM_PAINT, 0, 0);
}

bool OpenGLContext::mouseVisible() const
{
    return mMouseVisible;
}

void OpenGLContext::setVSyncEnabled(bool enable)
{
    makeCurrent();
    if (WGLEW_EXT_swap_control)
        wglSwapIntervalEXT(enable ? 1 : 0);
}

bool OpenGLContext::vsyncEnabled() const
{
    if (WGLEW_EXT_swap_control)
        return wglGetSwapIntervalEXT() != 0;
    else
        return false;
}

void OpenGLContext::makeCurrent()
{
    if (hwnd() && mHDC && mHGLRC)
        wglMakeCurrent(mHDC, mHGLRC);
}

void OpenGLContext::setMouseVisible(bool visible)
{
    mMouseVisible = visible;
    if (visible)
        while (ShowCursor(TRUE) <  0) {}
    else
        while (ShowCursor(FALSE) >= 0) {}
}

void OpenGLContext::setMousePosition(int x, int y)
{
    if (hwnd())
    {
        POINT pt = {x, y};
        ClientToScreen(hwnd(), &pt);
        SetCursorPos(pt.x, pt.y);
    }
}

void OpenGLContext::swapBuffers()
{
    if (hwnd() && hdc())
        SwapBuffers(hdc());
}

HWND OpenGLContext::hwnd() const
{
    return mhwnd;
}

HDC OpenGLContext::hdc() const
{
    return mHDC;
}

HGLRC OpenGLContext::hglrc() const
{
    return mHGLRC;
}

void OpenGLContext::setContinuousUpdate(bool continuous)
{
    mContinuousUpdate = continuous;
}

bool OpenGLContext::continuousUpdate() const
{
    return mContinuousUpdate;
}

const OpenGLContextFormat& OpenGLContext::openglContextInfo() const
{
    return mGLContextInfo;
}

void OpenGLContext::setOpenGLContextInfo(const OpenGLContextFormat& info)
{
    mGLContextInfo = info;
}

void OpenGLContext::ignoreNextMouseMoveEvent()
{
    mIgnoreNextMouseMoveEvent = true;
}

// this value is clamped to VL_MAX_TEXTURE_UNIT_COUNT
int OpenGLContext::textureUnitCount() const
{
    return mTextureUnitCount;
}


OpenGLContextFormat::OpenGLContextFormat() : mRGBABits(ivec4(8, 8, 8, 0))
    , mAccumRGBABits(ivec4(0, 0, 0, 0))
    , mHasDoubleBuffer(true)
    , mZBufferBits(24)
    , mStencilBufferBits(8)
    , mHasMultisample(false)
    , mMultisampleSamples(16)
    , mStereo(false)
    , mVSync(false)
{
}

int OpenGLContextFormat::bitsPerPixel() const
{
    return rgbaBits().r() + rgbaBits().g() + rgbaBits().b() + rgbaBits().a();
}

void OpenGLContextFormat::setRGBABits(int r, int g, int b, int a)
{
    mRGBABits = ivec4(r, g, b, a);
}

void OpenGLContextFormat::setAccumRGBABits(int r, int g, int b, int a)
{
    mAccumRGBABits = ivec4(r, g, b, a);
}

void OpenGLContextFormat::setDoubleBuffer(bool double_buffer_on)
{
    mHasDoubleBuffer = double_buffer_on;
}

void OpenGLContextFormat::setDepthBufferBits(int bits)
{
    mZBufferBits = bits;
}

void OpenGLContextFormat::setStencilBufferBits(int bits)
{
    mStencilBufferBits = bits;
}

void OpenGLContextFormat::setMultisample(bool multisample_on)
{
    mHasMultisample = multisample_on;
}

void OpenGLContextFormat::setMultisampleSamples(int samples)
{
    mMultisampleSamples = samples;
}

void OpenGLContextFormat::setStereo(bool stereo_on)
{
    mStereo = stereo_on;
}

void OpenGLContextFormat::setVSync(bool vsync_on)
{
    mVSync = vsync_on;
}

const ivec4& OpenGLContextFormat::rgbaBits() const
{
    return mRGBABits;
}

const ivec4& OpenGLContextFormat::accumRGBABits() const
{
    return mAccumRGBABits;
}

bool OpenGLContextFormat::doubleBuffer() const
{
    return mHasDoubleBuffer;
}

int OpenGLContextFormat::depthBufferBits() const
{
    return mZBufferBits;
}

int OpenGLContextFormat::stencilBufferBits() const
{
    return mStencilBufferBits;
}

bool OpenGLContextFormat::multisample() const
{
    return mHasMultisample;
}

int multisampleSamples() const
{
    return mMultisampleSamples;
}

bool OpenGLContextFormat::stereo() const
{
    return mStereo;
}

bool OpenGLContextFormat::vSync() const
{
    return mVSync;
}