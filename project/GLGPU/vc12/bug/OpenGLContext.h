
#pragma  once

#include "Vector4.hpp"
#include <set>

//The OpenGLContextFormat class encapsulates the settings of an OpenGL rendering context.
class OpenGLContextFormat
{
protected:
    ivec4 mRGBABits;
    ivec4 mAccumRGBABits;
    bool mHasDoubleBuffer;
    int mZBufferBits;
    int mStencilBufferBits;
    bool mHasMultisample;
    int mMultisampleSamples;
    bool mStereo;
    bool mVSync;
public:
    OpenGLContextFormat();
public:
    //! Returns rgbaBits().r() + rgbaBits().g() + rgbaBits().b() + rgbaBits().a()
    int bitsPerPixel() const;
    void setRGBABits(int r, int g, int b, int a);
    void setAccumRGBABits(int r, int g, int b, int a);
    void setDoubleBuffer(bool double_buffer_on);
    void setDepthBufferBits(int bits);
    void setStencilBufferBits(int bits);
    void setMultisample(bool multisample_on);
    void setMultisampleSamples(int samples);
    void setStereo(bool stereo_on);
    void setVSync(bool vsync_on);
    const ivec4& rgbaBits() const;
    const ivec4& accumRGBABits() const;
    bool doubleBuffer() const;
    int depthBufferBits() const;
    int stencilBufferBits() const;
    bool multisample() const;
    int multisampleSamples() const;
    bool stereo() const;
    bool vSync() const;
};

/**
    Represents an abstract GUI object containing an OpenGL context to which also keyboard, mouse or system events can be sent.
    OpenGLContext is an abstract class that wraps a minimal common subset of GUI APIs like Win32, Qt, wxWidgets, SDL, GLUT, etc. \n
    In order to respond to the events generated by the OpenGLContext you must subclass an UIEventListener and bind it to the OpenGLContext
    using the functions addEventListener(ref<UIEventListener>) and removeEventListener(ref<UIEventListener>).

    \par OpenGLContext custom implementation
    - Key_Alt/Ctrl/Shift events must always be notified before Key_Left/Right-Alt/Ctrl/Shift events.
    - Always update the mKeyboard structure appropriately especially with respect to Key_[Left/Right]-Alt/Ctrl/Shift events.
    - When cycling through EventListeners to dispatch the events you must do it on a temporary copy of mEventListeners so that
    the EventListeners can safely add/remove themselves or other EventListeners to the OpenGLContext itself.
*/
class OpenGLContext
{
public:
    OpenGLContext(HWND hwnd);
    ~OpenGLContext();
public:
    bool init(const OpenGLContextFormat& fmt);
    void release();
    //! Use this function when you want two OpenGL contexts to share their resources (display lists, textures, shader objects, buffer objects etc.)
    //! Equivalent to wglShareLists(this->hglrc(), hGLRC)
    //! \remarks
    //! If you want to share resources among two or more OpenGL contexts, you must call this function
    //! before you start creating any resources.
    void shareOpenGLResources(HGLRC hGLRC);

    //! Initializes the supported OpenGL extensions.
    void initExtensions(bool log = true);

    //! Returns true if the given extension is supported.
    //! \note This is a relatively slow function, don't use it inside loops and similar.
    bool isExtensionSupported(const char* ext_name);

    //! Asks to the windowing system that is managing the OpenGLContext to quit the application.
    virtual void quitApplication();
    virtual void update();

    virtual bool mouseVisible() const;
    virtual void setMouseVisible(bool bVisible);
    virtual void swapBuffers();
    virtual void makeCurrent();
    virtual void setMousePosition(int /*x*/, int /*y*/);
    void setVSyncEnabled(bool enable);
    bool vsyncEnabled() const;
public:
    HWND hwnd() const;
    HDC hdc() const;
    HGLRC hglrc() const;
    virtual void setContinuousUpdate(bool continuous);
    bool continuousUpdate() const;
    const OpenGLContextFormat& openglContextInfo() const;
    void setOpenGLContextInfo(const OpenGLContextFormat& info);
    void ignoreNextMouseMoveEvent();
    int textureUnitCount() const;
public:
    HWND mhwnd;
    OpenGLContextFormat mGLContextInfo;
    bool mMouseVisible;
    bool mContinuousUpdate;
    bool mIgnoreNextMouseMoveEvent;
    bool mFullscreen;
    int mTextureUnitCount;
    HDC mHDC;
    HGLRC mHGLRC;
};



